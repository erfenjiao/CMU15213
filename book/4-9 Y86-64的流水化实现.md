（１）取值阶段。
这个阶段最复杂的地方就是如何预测下一条指令的地址，实际上，指令在具体执行时，无非两种情况。一种是顺序执行，另外一种就是跳转执行。
①　顺序执行　halt  nop  rrmovq  irmovq  mrmovq  OPq  pushq  popq  cmovXX
　假如取值阶段取出的指令属于顺序执行的情况，那么，下一条在指令的地址可以通过当前指令的地址加上当前指令的长度计算得出。
②　跳转执行　call jxx
当取出的指令为跳转指令或者函数调用指令时，ＰＣ预测逻辑单元会直接将着两条指令中的常数字段，作为下一条指令的地址
跳转指令，有跳转和不跳转两种情况。如果跳转，下一条指令就是指令中的常数字段。
在之后的表述中，用 valC 表示跳转执行时下一条指令的地址。如果取值阶段取出的指令是返回指令，下一条指令就需要从栈中读出。
由于返回值的范围太大，所以在我们的设计中，不会尝试对返回地址做预测，既然无法预测，ＰＣ预测逻辑单元在预测下一条指令的地址时，采用与顺序执行的指令一样的方法来简单处理。
综上所述，ＰＣ预测逻辑单元，会根据指令类型，来预测下一条指令的地址究竟是 valP , 还是 valC　。
既然是预测下一条指令的地址，肯定有预测错误的情况，对于图中的PC选择逻辑单元可以理解为纠错部件。
通俗点讲，如果ＰＣ选择逻辑单元出错，之后的ＰＣ选择逻辑单元会根据实际情况来改正预测的错误。

根据寄存器的ＩＤ从寄存器文件中的读取数据，寄存器ＩＤ由ｓｒｃＡ和ｓｒｃＢ的逻辑单元输入都寄存器文件最终译码的结果。
（２）译码阶段。主要是根据寄存器的ＩＤ从寄存器文件中读取数据，寄存器ＩＤ由rA,rB提供，经过　 srcA srcB逻辑单元输入到寄存器文件，最终译码的结果用　valA valB　来表示。
为了提高流水线的执行效率，我们引入了数据转发的执行机制。通俗点讲，数据转发可以直接使用相关寄存器的数据，而不是等写回阶段更新完寄存器的值之后，再从寄存器的文件中读取。（数据转发复习 4-7）
所以译码阶段我们需要去判断究竟是直接采用转发的数据，还是使用寄存器文件中读取数据。
判断依据是根据当前需要读取寄存器的ＩＤ值，与转发的目的寄存器的ＩＤ值是否相等。
－－
译码阶段由于加入了转发机制从而导致硬件设计变得相对复杂了。
首先，我们需要看看究竟是那些数据需要被转发。
1. 第一个数据是ＡＬＵ产生的输出结果。如果按照正常指令执行流程，ＡＬＵ的输出结果还需要经过写回，访存之后才能完成寄存器数据的更新。采用数据转发的设计，ＡＬＵ的输出结果可以马上作为译码阶段的结果，从而避免了等待数据协会寄存器文件后再去读的问题。
2. 第二个转发源，是内存的输出数据，与ＡＬＵ的输出结果相似，通过转发内存的输出数据，也可以避免等待问题。
3. 第三个转发原是访存阶段时，对寄存器写入端口Ｅ还没有进行写入的数据。
4. 第四个转发源是写回阶段时，对寄存器写入端口Ｍ还没有写入的数据
5. 第五个转发源是写回阶段时，对寄存器写入端口Ｅ还没有写入的数据
其中，每一个转发源包括两部分，一部分是寄存器的ＩＤ值，用白色信号线表示，一部分是转发数据，用红色的数据线表示。
这五个转发源存在优先级，转发逻辑单元首先会检查执行阶段的转发源，然后是访存阶段，最后才是写回阶段。
